//! This file is for Beneš network related functions
//!
//! For the implementation strategy, see
//! “McBits Revisited” by Tung Chou (2017)
//! <https://eprint.iacr.org/2017/793.pdf>

use crate::gf::Gf;
use crate::params::GFBITS;
use crate::params::SYS_N;
use crate::transpose;
use crate::util;

/// Layers of the Beneš network. The required size of `data` and `bits` depends on the value `lgs`.
/// NOTE const expressions are not sophisticated enough in rust yet to represent this relationship.
///
/// | lgs | data.len() | bits.len() |
/// | ------ | ------ | ------ |
/// | 8 | 512 | 256 |
/// | 7 | 256 | 128 |
/// | 6 | 128 | 64 |
/// | 5 | 64 | 32 |
/// | 4 | 64 | 32 |
#[cfg(any(feature = "mceliece348864", feature = "mceliece348864f"))]
fn layer(data: &mut [u64], bits: &[u64], lgs: usize) {
    let mut index = 0;

    let s = 1 << lgs;

    let mut i = 0usize;
    while i < 64 {
        for j in i..(i + s) {
            let mut d = data[j + 0] ^ data[j + s];
            d &= bits[index];
            index += 1;

            data[j + 0] ^= d;
            data[j + s] ^= d;
        }
        i += s * 2;
    }
}

/// Inner layers of the Beneš network. The required size of `data` and `bits` depends on the value `lgs`.
/// `data[0]`, `data[1]` and `bits` must have the same length; namely `2^(lgs + 1)` with `lgs ≥ 5`.
#[cfg(not(any(feature = "mceliece348864", feature = "mceliece348864f")))]
fn layer_in<const L: usize>(data: &mut [[u64; L]; 2], bits: &[u64; L], lgs: usize) {
    let mut d: u64;
    let mut index = 0;

    let s = 1 << lgs;

    let mut i = 0usize;
    while i < 64 {
        for j in i..(i + s) {
            d = data[0][j + 0] ^ data[0][j + s];
            d &= bits[index];
            index += 1;

            data[0][j + 0] ^= d;
            data[0][j + s] ^= d;

            d = data[1][j + 0] ^ data[1][j + s];
            d &= bits[index];
            index += 1;

            data[1][j + 0] ^= d;
            data[1][j + s] ^= d;
        }
        i += s * 2;
    }
}

/// Exterior layers of the Beneš network
// TODO this implementation is quite different from the C implementation. Just remove the s==64 special case?
// attempt maybe iterators
// for item in 2darray.iter().flatten() { … }
// or try https://docs.rs/bytemuck/1.7.2/bytemuck/ crate
/// NOTE const expressions are not sophisticated enough in rust yet to represent this relationship.
///
/// | lgs | data[0].len() == data[1].len() | bits.len() |
/// | ------ | ------ | ------ |
/// | 8 | 512 | 256 |
/// | 7 | 256 | 128 |
/// | 6 | 128 | 64 |
/// | 5 | 128 | 64 |
/// | 4 | 128 | 64 |
#[cfg(not(any(feature = "mceliece348864", feature = "mceliece348864f")))]
fn layer_ex(data: &mut [[u64; 64]; 2], bits: &[u64], lgs: usize) {
    let mut d: u64;
    let mut index = 0;
    let mut index2 = 32;

    let s = 1 << lgs;
    if s == 64 {
        for j in 0..64 {
            d = data[0][j + 0] ^ data[1][j];
            d &= bits[index];
            index += 1;

            data[0][j + 0] ^= d;
            data[1][j] ^= d;
        }
    } else {
        let mut i: usize = 0;
        while i < 64 {
            for j in i..(i + s) {
                d = data[0][j + 0] ^ data[0][j + s];
                d &= bits[index];
                index += 1;

                data[0][j + 0] ^= d;
                data[0][j + s] ^= d;

                d = data[1][j + 0] ^ data[1][j + s];
                d &= bits[index2]; // 64
                index2 += 1;

                data[1][j + 0] ^= d;
                data[1][j + s] ^= d;
            }
            i += s * 2;
        }
    }
}

/// Apply Beneš network in-place to array `r` based on configuration `bits` and `rev`.
/// Here, `r` is a sequence of bits to be permuted.
/// `bits` defines the condition bits configuring the Beneš network and
/// `rev` toggles between normal application (0) or its inverse (!0).
#[cfg(any(feature = "mceliece348864", feature = "mceliece348864f"))]
fn apply_benes(r: &mut [u8; (1 << GFBITS) / 8], bits: &[u8], rev: usize) {
    let mut bs = [0u64; 64];
    let mut cond = [0u64; 64];

    if rev == 0 {
        for i in 0..64 {
            bs[i] = util::load8(&r[i*8..(i + 1)*8]);
        }

        transpose::transpose_64x64_inplace(&mut bs);

        for low in 0..6 {
            for i in 0..64 {
                cond[i] = util::load4(&bits[low*256 + i*4..]) as u64;
            }
            transpose::transpose_64x64_inplace(&mut cond);
            layer(&mut bs, &cond, low);
        }

        transpose::transpose_64x64_inplace(&mut bs);

        for low in 0..6 {
            for i in 0..32 {
                cond[i] = util::load8(&bits[(low + 6)*256 + i*8..]);
            }
            layer(&mut bs, &cond, low);
        }
        for low in (0..5).rev() {
            for i in 0..32 {
                cond[i] = util::load8(&bits[(4 - low + 6 + 6)*256 + i*8..]);
            }
            layer(&mut bs, &cond, low);
        }

        transpose::transpose_64x64_inplace(&mut bs);

        for low in (0..6).rev() {
            for i in 0..64 {
                cond[i] = util::load4(&bits[(5 - low + 6 + 6 + 5)*256 + i*4..]) as u64;
            }
            transpose::transpose_64x64_inplace(&mut cond);
            layer(&mut bs, &cond, low);
        }

        transpose::transpose_64x64_inplace(&mut bs);

        for i in 0..64 {
            util::store8(&mut r[i*8..], bs[i]);
        }

    } else {
        for i in 0..64 {
            bs[i] = util::load8(&r[i*8..(i + 1)*8]);
        }

        transpose::transpose_64x64_inplace(&mut bs);

        for low in 0..6 {
            for i in 0..64 {
                cond[i] = util::load4(&bits[(2 * GFBITS - 2) * 256 - low * 256 + i*4..]) as u64;
            }
            transpose::transpose_64x64_inplace(&mut cond);
            layer(&mut bs, &cond, low);
        }

        transpose::transpose_64x64_inplace(&mut bs);

        for low in 0..6 {
            for i in 0..32 {
                cond[i] = util::load8(&bits[(2 * GFBITS - 2 - 6) * 256 - low * 256 + i*8..]);
            }
            layer(&mut bs, &cond, low);
        }
        for low in (0..5).rev() {
            for i in 0..32 {
                cond[i] = util::load8(&bits[(2 * GFBITS - 2 - 6 - 6) * 256 - (4-low) * 256 + i*8..]);
                layer(&mut bs, &cond, low);
            }
        }

        transpose::transpose_64x64_inplace(&mut bs);

        for low in (0..6).rev() {
            for i in 0..64 {
                cond[i] = util::load4(&bits[(2 * GFBITS - 2 - 6 - 6 - 5) * 256 - (5-low) * 265 +  i*4..]) as u64;
            }
            transpose::transpose_64x64_inplace(&mut cond);
            layer(&mut bs, &cond, low);
        }

        transpose::transpose_64x64_inplace(&mut bs);

        for i in 0..64 {
            util::store8(&mut r[i*8..], bs[i]);
        }
    }
}

/// Apply Beneš network in-place to array `r` based on configuration `bits` and `rev`.
/// Here, `r` is a sequence of bits to be permuted.
/// `bits` defines the condition bits configuring the Beneš network and
/// `rev` toggles between normal application (0) or its inverse (!0).
#[cfg(not(any(feature = "mceliece348864", feature = "mceliece348864f")))]
fn apply_benes(r: &mut [u8; (1 << GFBITS) / 8], bits: &[u8], rev: usize) {
    let mut r_int_v = [[0u64; 64]; 2];
    let mut r_int_h = [[0u64; 64]; 2];
    let mut b_int_v = [0u64; 64];
    let mut b_int_h = [0u64; 64];

    let mut calc_index = if rev == 0 { 0 } else { 12288 };

    let mut i: usize = 0;
    for chunk in r.chunks_mut(16) {
        let (subchunk1, subchunk2) = chunk.split_at_mut(8);
        r_int_v[0][i] = util::load8(subchunk1);
        r_int_v[1][i] = util::load8(subchunk2);

        i += 1;
    }

    transpose::transpose(&mut r_int_h[0], r_int_v[0]);
    transpose::transpose(&mut r_int_h[1], r_int_v[1]);

    let mut iter = 0;
    while iter <= 6 {
        i = 0;
        for chunk in bits[calc_index..(calc_index + 512)].chunks(8) {
            b_int_v[i] = util::load8(chunk);
            i += 1;
            if i == 64 {
                break;
            }
        }

        calc_index = if rev == 0 {
            calc_index + 512
        } else {
            calc_index - 1024
        };

        transpose::transpose(&mut b_int_h, b_int_v);

        layer_ex(&mut r_int_h, &mut b_int_h, iter);

        iter += 1;
    }

    transpose::transpose(&mut r_int_v[0], r_int_h[0]);
    transpose::transpose(&mut r_int_v[1], r_int_h[1]);

    let mut iter: usize = 0;
    while iter <= 5 {
        for (i, chunk) in bits[calc_index..(calc_index + 512)].chunks(8).enumerate() {
            b_int_v[i] = util::load8(chunk);
        }

        calc_index = if rev == 0 {
            calc_index + 512
        } else {
            calc_index - 1024
        };

        layer_in(&mut r_int_v, &mut b_int_v, iter);

        iter += 1;
    }

    for iter in (0..=4).rev() {
        for (i, chunk) in bits[calc_index..(calc_index + 512)].chunks(8).enumerate() {
            b_int_v[i] = util::load8(chunk);
        }
        calc_index = if rev == 0 {
            calc_index + 512
        } else {
            calc_index - 1024
        };

        layer_in(&mut r_int_v, &mut b_int_v, iter);
    }

    transpose::transpose(&mut r_int_h[0], r_int_v[0]);
    transpose::transpose(&mut r_int_h[1], r_int_v[1]);

    for iter in (0..=6).rev() {
        for (i, chunk) in bits[calc_index..(calc_index + 512)].chunks(8).enumerate() {
            b_int_v[i] = util::load8(chunk);
        }
        calc_index = if rev == 0 {
            calc_index + 512
        } else {
            calc_index - 1024
        };

        transpose::transpose(&mut b_int_h, b_int_v);

        layer_ex(&mut r_int_h, &mut b_int_h, iter);
    }

    transpose::transpose(&mut r_int_v[0], r_int_h[0]);
    transpose::transpose(&mut r_int_v[1], r_int_h[1]);

    for (i, chunk) in r.chunks_mut(16).enumerate() {
        let (subchunk1, subchunk2) = chunk.split_at_mut(8);
        util::store8(subchunk1, r_int_v[0][i]);
        util::store8(subchunk2, r_int_v[1][i]);
    }
}

pub(crate) fn support_gen(s: &mut [Gf; SYS_N], c: &[u8]) {
    let mut a: Gf;
    let mut l = [[0u8; (1 << GFBITS) / 8]; GFBITS];

    for i in 0..(1 << GFBITS) {
        a = util::bitrev(i as Gf);

        for j in 0..GFBITS {
            l[j][i / 8] |= (((a >> j) & 1) << (i % 8)) as u8;
        }
    }

    for j in 0..GFBITS {
        apply_benes(&mut l[j], c, 0);
    }

    for i in 0..SYS_N {
        s[i] = 0;
        for j in (0..=(GFBITS - 1)).rev() {
            s[i] <<= 1;
            s[i] |= ((l[j][i / 8] >> (i % 8)) & 1) as u16;
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::convert::TryFrom;
    use crate::api::{CRYPTO_SECRETKEYBYTES, CRYPTO_PRIMITIVE};

    fn get(name: &str) -> Vec<u64> {
        let fullname = format!("{}_{}", CRYPTO_PRIMITIVE, name);
        crate::TestData::new().u64vec(&fullname)
    }

    fn get64(name: &str) -> [u64; 64] {
        <[u64; 64]>::try_from(get(name).as_slice()).unwrap()
    }

    #[cfg(any(feature = "mceliece348864", feature = "mceliece348864f"))]
    #[test]
    fn test_layer() {
        let mut data = [0u64; 64];
        let mut bits = [0u64; 32];
        for i in 0..64 {
            data[i] = 0xAAAA ^ (i as u64 * 17);
        }
        for i in 0..32 {
            bits[i] = (i as u64) << 3;
        }
        layer(&mut data, &bits, 4);
        assert_eq!(data, [0xAAAA, 0xAABB, 0xAA98, 0xAA89, 0xAAEE, 0xAADF, 0xAADC, 0xAAED, 0xAA22, 0xAA33, 0xAA10, 0xAA41, 0xAA66, 0xAA57, 0xAA54, 0xAA25, 0xABBA, 0xAB8B, 0xAB88, 0xABF9, 0xABFE, 0xABEF, 0xABCC, 0xAB1D, 0xAB32, 0xAB03, 0xAB00, 0xAB31, 0xAB76, 0xAB67, 0xAB44, 0xA8D5, 0xA88A, 0xA89B, 0xA8F8, 0xA8E9, 0xA8CE, 0xA87F, 0xA83C, 0xA80D, 0xA802, 0xA853, 0xA870, 0xA861, 0xA846, 0xA8B7, 0xA9B4, 0xA985, 0xA99A, 0xA9EB, 0xA9E8, 0xA9D9, 0xA9DE, 0xA98F, 0xA92C, 0xA93D, 0xA912, 0xA923, 0xA960, 0xA951, 0xA956, 0xAE47, 0xAEA4, 0xAEB5]);
    }

    #[cfg(any(feature = "mceliece348864", feature = "mceliece348864f"))]
    #[test]
    fn test_layer_2() {
        let mut data_arg = get64("benes_layer_data_before");
        let bits_arg = get("benes_layer_bits");
        layer(&mut data_arg, &bits_arg, 0);
        let actual_data = data_arg;

        let expected_data = get64("benes_layer_data_after");

        assert_eq!(actual_data, expected_data);
    }

    #[cfg(not(any(feature = "mceliece348864", feature = "mceliece348864f")))]
    #[test]
    fn test_layer_in() {
        let data0_arg = get64("benes_layer_in_data0_before");
        let data1_arg = get64("benes_layer_in_data1_before");
        let mut data_arg = [data0_arg, data1_arg];
        let bits_arg = get64("benes_layer_in_bits");
        layer_in(&mut data_arg, &bits_arg, 0);
        let actual_data = data_arg;

        let expected_data0 = get64("benes_layer_in_data0_after");
        let expected_data1 = get64("benes_layer_in_data1_after");
        let expected_data = [expected_data0, expected_data1];

        assert_eq!(actual_data, expected_data);
    }

    #[cfg(not(any(feature = "mceliece348864", feature = "mceliece348864f")))]
    #[test]
    fn test_layer_ex() {
        let mut data = [[0u64; 64]; 2];
        let mut bits = [0u64; 64];

        for i in 0..64 {
            data[0][i] = 0xFC81 ^ (i as u64 * 17);
            data[1][i] = 0x9837 ^ (i as u64 * 3);
        }
        for i in 0..64 {
            bits[i] = (i as u64) << 3;
        }
        layer_ex(&mut data, &bits, 5);

        assert_eq!(data, [[0xFC81, 0xFC90, 0xFCA3, 0xFCB2, 0xFCE5, 0xFCF4, 0xFCC7, 0xFCD6, 0xFC09, 0xFC18, 0xFC6B, 0xFC7A, 0xFC6D, 0xFC7C, 0xFC0F, 0xFC1E, 0xFD91, 0xFDA0, 0xFDB3, 0xFDC2, 0xFDF5, 0xFD44, 0xFD57, 0xFD26, 0xFD19, 0xFD68, 0xFD7B, 0xFD4A, 0xFD7D, 0xFD8C, 0xFD9F, 0xFEAE, 0xFEA1, 0xFEB0, 0xFEC3, 0xFED2, 0xFEC5, 0xFED4, 0xFE27, 0xFE36, 0xFE29, 0xFE38, 0xFE0B, 0xFE1A, 0xFE4D, 0xFE5C, 0xFFEF, 0xFFFE, 0xFFB1, 0xFFC0, 0xFFD3, 0xFFE2, 0xFFD5, 0xFFA4, 0xFFB7, 0xFF06, 0xFF39, 0xFF08, 0xFF1B, 0xFF6A, 0xFF5D, 0xF86C, 0xF87F, 0xF88E], [0x9837, 0x9834, 0x9831, 0x983E, 0x981B, 0x9818, 0x9805, 0x9802, 0x986F, 0x986C, 0x9869, 0x9816, 0x9833, 0x9830, 0x983D, 0x983A, 0x9887, 0x9884, 0x9881, 0x988E, 0x98AB, 0x98A8, 0x98D5, 0x98D2, 0x98BF, 0x98BC, 0x98B9, 0x98A6, 0x9883, 0x9880, 0x988D, 0x988A, 0x9857, 0x9854, 0x9851, 0x985E, 0x987B, 0x9878, 0x9865, 0x9862, 0x980F, 0x980C, 0x9809, 0x98B6, 0x9893, 0x9890, 0x989D, 0x989A, 0x9827, 0x9824, 0x9821, 0x982E, 0x980B, 0x9808, 0x9835, 0x9832, 0x985F, 0x985C, 0x9859, 0x9846, 0x9863, 0x9860, 0x986D, 0x986A]]);
    }

    #[test]
    fn test_apply_benes() {
        // Basic testcase
        let mut l = [31u8; (1 << GFBITS) / 8];
        let mut bits = [0u8; CRYPTO_SECRETKEYBYTES + 40];
        bits[0] = 255;

        let mut compare_array = [31u8; (1 << GFBITS) / 8];
        compare_array[0] = 47;
        compare_array[1] = 47;

        apply_benes(&mut l, &mut bits, 0);

        assert_eq!(l, compare_array);
    }

    #[test]
    fn test_apply_benes_2() {
        let mut r = [0u8; (1 << GFBITS) / 8];
        let mut bits = [0u8; CRYPTO_SECRETKEYBYTES + 40];

        for i in 0..(1 << GFBITS) / 8 {
            r[i] = (i as u8).wrapping_mul(13).wrapping_add(3) & 0xFF;
        }
        for i in 0..(CRYPTO_SECRETKEYBYTES + 40) {
            bits[i] = (i as u8).wrapping_shl(3).wrapping_add(13) & 0xFF;
        }

        apply_benes(&mut r, &bits, 0);

        assert_eq!(r, [0x03, 0x10, 0x1D, 0x2A, 0x37, 0x44, 0x51, 0x5E, 0x6B, 0x78, 0x85, 0x92, 0x9F, 0xAC, 0xB9, 0xC6, 0xD3, 0xE0, 0xED, 0xFA, 0x07, 0x14, 0x21, 0x2E, 0x3B, 0x48, 0x55, 0x62, 0x6F, 0x7C, 0x89, 0x96, 0xA3, 0xB0, 0xBD, 0xCA, 0xD7, 0xE4, 0xF1, 0xFE, 0x0B, 0x18, 0x25, 0x32, 0x3F, 0x4C, 0x59, 0x66, 0x73, 0x80, 0x8D, 0x9A, 0xA7, 0xB4, 0xC1, 0xCE, 0xDB, 0xE8, 0xF5, 0x02, 0x0F, 0x1C, 0x29, 0x36, 0x43, 0x50, 0x5D, 0x6A, 0x77, 0x84, 0x91, 0x9E, 0xAB, 0xB8, 0xC5, 0xD2, 0xDF, 0xEC, 0xF9, 0x06, 0x13, 0x20, 0x2D, 0x3A, 0x47, 0x54, 0x61, 0x6E, 0x7B, 0x88, 0x95, 0xA2, 0xAF, 0xBC, 0xC9, 0xD6, 0xE3, 0xF0, 0xFD, 0x0A, 0x17, 0x24, 0x31, 0x3E, 0x4B, 0x58, 0x65, 0x72, 0x7F, 0x8C, 0x99, 0xA6, 0xB3, 0xC0, 0xCD, 0xDA, 0xE7, 0xF4, 0x01, 0x0E, 0x1B, 0x28, 0x35, 0x42, 0x4F, 0x5C, 0x69, 0x76, 0x83, 0x90, 0x9D, 0xAA, 0xB7, 0xC4, 0xD1, 0xDE, 0xEB, 0xF8, 0x05, 0x12, 0x1F, 0x2C, 0x39, 0x46, 0x53, 0x60, 0x6D, 0x7A, 0x87, 0x94, 0xA1, 0xAE, 0xBB, 0xC8, 0xD5, 0xE2, 0xEF, 0xFC, 0x09, 0x16, 0x23, 0x30, 0x3D, 0x4A, 0x57, 0x64, 0x71, 0x7E, 0x8B, 0x98, 0xA5, 0xB2, 0xBF, 0xCC, 0xD9, 0xE6, 0xF3, 0x00, 0x0D, 0x1A, 0x27, 0x34, 0x41, 0x4E, 0x5B, 0x68, 0x75, 0x82, 0x8F, 0x9C, 0xA9, 0xB6, 0xC3, 0xD0, 0xDD, 0xEA, 0xF7, 0x04, 0x11, 0x1E, 0x2B, 0x38, 0x45, 0x52, 0x5F, 0x6C, 0x79, 0x86, 0x93, 0xA0, 0xAD, 0xBA, 0xC7, 0xD4, 0xE1, 0xEE, 0xFB, 0x08, 0x15, 0x22, 0x2F, 0x3C, 0x49, 0x56, 0x63, 0x70, 0x7D, 0x8A, 0x97, 0xA4, 0xB1, 0xBE, 0xCB, 0xD8, 0xE5, 0xF2, 0xFF, 0x0C, 0x19, 0x26, 0x33, 0x40, 0x4D, 0x5A, 0x67, 0x74, 0x81, 0x8E, 0x9B, 0xA8, 0xB5, 0xC2, 0xCF, 0xDC, 0xE9, 0xF6, 0x03, 0x10, 0x1D, 0x2A, 0x37, 0x44, 0x51, 0x5E, 0x6B, 0x78, 0x85, 0x92, 0x9F, 0xAC, 0xB9, 0xC6, 0xD3, 0xE0, 0xED, 0xFA, 0x07, 0x14, 0x21, 0x2E, 0x3B, 0x48, 0x55, 0x62, 0x6F, 0x7C, 0x89, 0x96, 0xA3, 0xB0, 0xBD, 0xCA, 0xD7, 0xE4, 0xF1, 0xFE, 0x0B, 0x18, 0x25, 0x32, 0x3F, 0x4C, 0x59, 0x66, 0x73, 0x80, 0x8D, 0x9A, 0xA7, 0xB4, 0xC1, 0xCE, 0xDB, 0xE8, 0xF5, 0x02, 0x0F, 0x1C, 0x29, 0x36, 0x43, 0x50, 0x5D, 0x6A, 0x77, 0x84, 0x91, 0x9E, 0xAB, 0xB8, 0xC5, 0xD2, 0xDF, 0xEC, 0xF9, 0x06, 0x13, 0x20, 0x2D, 0x3A, 0x47, 0x54, 0x61, 0x6E, 0x7B, 0x88, 0x95, 0xA2, 0xAF, 0xBC, 0xC9, 0xD6, 0xE3, 0xF0, 0xFD, 0x0A, 0x17, 0x24, 0x31, 0x3E, 0x4B, 0x58, 0x65, 0x72, 0x7F, 0x8C, 0x99, 0xA6, 0xB3, 0xC0, 0xCD, 0xDA, 0xE7, 0xF4, 0x01, 0x0E, 0x1B, 0x28, 0x35, 0x42, 0x4F, 0x5C, 0x69, 0x76, 0x83, 0x90, 0x9D, 0xAA, 0xB7, 0xC4, 0xD1, 0xDE, 0xEB, 0xF8, 0x05, 0x12, 0x1F, 0x2C, 0x39, 0x46, 0x53, 0x60, 0x6D, 0x7A, 0x87, 0x94, 0xA1, 0xAE, 0xBB, 0xC8, 0xD5, 0xE2, 0xEF, 0xFC, 0x09, 0x16, 0x23, 0x30, 0x3D, 0x4A, 0x57, 0x64, 0x71, 0x7E, 0x8B, 0x98, 0xA5, 0xB2, 0xBF, 0xCC, 0xD9, 0xE6, 0xF3, 0x00, 0x0D, 0x1A, 0x27, 0x34, 0x41, 0x4E, 0x5B, 0x68, 0x75, 0x82, 0x8F, 0x9C, 0xA9, 0xB6, 0xC3, 0xD0, 0xDD, 0xEA, 0xF7, 0x04, 0x11, 0x1E, 0x2B, 0x38, 0x45, 0x52, 0x5F, 0x6C, 0x79, 0x86, 0x93, 0xA0, 0xAD, 0xBA, 0xC7, 0xD4, 0xE1, 0xEE, 0xFB, 0x08, 0x15, 0x22, 0x2F, 0x3C, 0x49, 0x56, 0x63, 0x70, 0x7D, 0x8A, 0x97, 0xA4, 0xB1, 0xBE, 0xCB, 0xD8, 0xE5, 0xF2, 0xFF, 0x0C, 0x19, 0x26, 0x33, 0x40, 0x4D, 0x5A, 0x67, 0x74, 0x81, 0x8E, 0x9B, 0xA8, 0xB5, 0xC2, 0xCF, 0xDC, 0xE9, 0xF6, 0x03, 0x10, 0x1D, 0x2A, 0x37, 0x44, 0x51, 0x5E, 0x6B, 0x78, 0x85, 0x92, 0x9F, 0xAC, 0xB9, 0xC6, 0xD3, 0xE0, 0xED, 0xFA, 0x07, 0x14, 0x21, 0x2E, 0x3B, 0x48, 0x55, 0x62, 0x6F, 0x7C, 0x89, 0x96, 0xA3, 0xB0, 0xBD, 0xCA, 0xD7, 0xE4, 0xF1, 0xFE, 0x0B, 0x18, 0x25, 0x32, 0x3F, 0x4C, 0x59, 0x66, 0x73, 0x80, 0x8D, 0x9A, 0xA7, 0xB4, 0xC1, 0xCE, 0xDB, 0xE8, 0xF5, 0x02, 0x0F, 0x1C, 0x29, 0x36, 0x43, 0x50, 0x5D, 0x6A, 0x77, 0x84, 0x91, 0x9E, 0xAB, 0xB8, 0xC5, 0xD2, 0xDF, 0xEC, 0xF9, 0x06, 0x13, 0x20, 0x2D, 0x3A, 0x47, 0x54, 0x61, 0x6E, 0x7B, 0x88, 0x95, 0xA2, 0xAF, 0xBC, 0xC9, 0xD6, 0xE3, 0xF0, 0xFD, 0x0A, 0x17, 0x24, 0x31, 0x3E, 0x4B, 0x58, 0x65, 0x72, 0x7F, 0x8C, 0x99, 0xA6, 0xB3, 0xC0, 0xCD, 0xDA, 0xE7, 0xF4, 0x01, 0x0E, 0x1B, 0x28, 0x35, 0x42, 0x4F, 0x5C, 0x69, 0x76, 0x83, 0x90, 0x9D, 0xAA, 0xB7, 0xC4, 0xD1, 0xDE, 0xEB, 0xF8, 0x05, 0x12, 0x1F, 0x2C, 0x39, 0x46, 0x53, 0x60, 0x6D, 0x7A, 0x87, 0x94, 0xA1, 0xAE, 0xBB, 0xC8, 0xD5, 0xE2, 0xEF, 0xFC, 0x09, 0x16, 0x23, 0x30, 0x3D, 0x4A, 0x57, 0x64, 0x71, 0x7E, 0x8B, 0x98, 0xA5, 0xB2, 0xBF, 0xCC, 0xD9, 0xE6, 0xF3, 0x00, 0x0D, 0x1A, 0x27, 0x34, 0x41, 0x4E, 0x5B, 0x68, 0x75, 0x82, 0x8F, 0x9C, 0xA9, 0xB6, 0xC3, 0xD0, 0xDD, 0xEA, 0xF7, 0x04, 0x11, 0x1E, 0x2B, 0x38, 0x45, 0x52, 0x5F, 0x6C, 0x79, 0x86, 0x93, 0xA0, 0xAD, 0xBA, 0xC7, 0xD4, 0xE1, 0xEE, 0xFB, 0x08, 0x15, 0x22, 0x2F, 0x3C, 0x49, 0x56, 0x63, 0x70, 0x7D, 0x8A, 0x97, 0xA4, 0xB1, 0xBE, 0xCB, 0xD8, 0xE5, 0xF2, 0xFF, 0x0C, 0x19, 0x26, 0x33, 0x40, 0x4D, 0x5A, 0x67, 0x74, 0x81, 0x8E, 0x9B, 0xA8, 0xB5, 0xC2, 0xCF, 0xDC, 0xE9, 0xF6, 0x03, 0x10, 0x1D, 0x2A, 0x37, 0x44, 0x51, 0x5E, 0x6B, 0x78, 0x85, 0x92, 0x9F, 0xAC, 0xB9, 0xC6, 0xD3, 0xE0, 0xED, 0xFA, 0x07, 0x14, 0x21, 0x2E, 0x3B, 0x48, 0x55, 0x62, 0x6F, 0x7C, 0x89, 0x96, 0xA3, 0xB0, 0xBD, 0xCA, 0xD7, 0xE4, 0xF1, 0xFE, 0x0B, 0x18, 0x25, 0x32, 0x3F, 0x4C, 0x59, 0x66, 0x73, 0x80, 0x8D, 0x9A, 0xA7, 0xB4, 0xC1, 0xCE, 0xDB, 0xE8, 0xF5, 0x02, 0x0F, 0x1C, 0x29, 0x36, 0x43, 0x50, 0x5D, 0x6A, 0x77, 0x84, 0x91, 0x9E, 0xAB, 0xB8, 0xC5, 0xD2, 0xDF, 0xEC, 0xF9, 0x06, 0x13, 0x20, 0x2D, 0x3A, 0x47, 0x54, 0x61, 0x6E, 0x7B, 0x88, 0x95, 0xA2, 0xAF, 0xBC, 0xC9, 0xD6, 0xE3, 0xF0, 0xFD, 0x0A, 0x17, 0x24, 0x31, 0x3E, 0x4B, 0x58, 0x65, 0x72, 0x7F, 0x8C, 0x99, 0xA6, 0xB3, 0xC0, 0xCD, 0xDA, 0xE7, 0xF4, 0x01, 0x0E, 0x1B, 0x28, 0x35, 0x42, 0x4F, 0x5C, 0x69, 0x76, 0x83, 0x90, 0x9D, 0xAA, 0xB7, 0xC4, 0xD1, 0xDE, 0xEB, 0xF8, 0x05, 0x12, 0x1F, 0x2C, 0x39, 0x46, 0x53, 0x60, 0x6D, 0x7A, 0x87, 0x94, 0xA1, 0xAE, 0xBB, 0xC8, 0xD5, 0xE2, 0xEF, 0xFC, 0x09, 0x16, 0x23, 0x30, 0x3D, 0x4A, 0x57, 0x64, 0x71, 0x7E, 0x8B, 0x98, 0xA5, 0xB2, 0xBF, 0xCC, 0xD9, 0xE6, 0xF3, 0x00, 0x0D, 0x1A, 0x27, 0x34, 0x41, 0x4E, 0x5B, 0x68, 0x75, 0x82, 0x8F, 0x9C, 0xA9, 0xB6, 0xC3, 0xD0, 0xDD, 0xEA, 0xF7, 0x04, 0x11, 0x1E, 0x2B, 0x38, 0x45, 0x52, 0x5F, 0x6C, 0x79, 0x86, 0x93, 0xA0, 0xAD, 0xBA, 0xC7, 0xD4, 0xE1, 0xEE, 0xFB, 0x08, 0x15, 0x22, 0x2F, 0x3C, 0x49, 0x56, 0x63, 0x70, 0x7D, 0x8A, 0x97, 0xA4, 0xB1, 0xBE, 0xCB, 0xD8, 0xE5, 0xF2, 0xFF, 0x0C, 0x19, 0x26, 0x33, 0x40, 0x4D, 0x5A, 0x67, 0x74, 0x81, 0x8E, 0x9B, 0xA8, 0xB5, 0xC2, 0xCF, 0xDC, 0xE9, 0xF6]);
    }
}
